/*****************************************************************************
*
* Copyright (c) 2000 - 2012, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//                            avtVlsvFileFormat.C                           //
// ************************************************************************* //

#include <avtVlsvFileFormat.h>

#include <string>

#include <vtkPoints.h>
#include <vtkFloatArray.h>
#include <vtkRectilinearGrid.h>
#include <vtkStructuredGrid.h>
#include <vtkUnstructuredGrid.h>

#include <avtDatabaseMetaData.h>

#include <DBOptionsAttributes.h>
#include <Expression.h>

#include <InvalidVariableException.h>

// Include VisIt and VTK headers:
#include <DebugStream.h>
#include <vtkCellType.h>
#include <InvalidDBTypeException.h>

// Include required standard headers:
#include <stdint.h>
#include <list>
#include <set>
#include <limits>
#include <chrono>

#include <mesh_metadata_visit_point.h>
#include <mesh_metadata_visit_quad_multi.h>
#include <mesh_metadata_visit_ucd_amr.h>
#include <mesh_metadata_visit_ucd_multi.h>
#include <mesh_metadata_visit_ucd_generic_multi.h>

#include <mesh_reader_visit_point.h>
#include <mesh_reader_visit_quad_multi.h>
#include <mesh_reader_visit_ucd_amr.h>
#include <mesh_reader_visit_ucd_multi.h>
#include <mesh_reader_visit_ucd_generic_multi.h>

#ifdef PARALLEL
   #include <mpi.h>
#endif

using namespace std;

int avtVlsvFileFormat::objectCounter = 0;

static const int VTK_DATATYPE_NOT_FOUND = -999;

// ****************************************************************************
//  Method: avtVlsvFileFormat constructor
//
//  Programmer: sandroos -- generated by xml2avt
//  Creation:   Fri Jan 25 14:19:12 PST 2013
//
// ****************************************************************************

/**
 * 
 * If the plugin cannot open the given file, it must throw an
 * InvalidDBTypeException.
 * 
 * Notes from "Getting Data into VisIt" document:
 * Constructor should do as little work as possible, and especially avoid
 * opening the input file. Instead one should override ActivateTimestep 
 * method and open the file there.
 */
avtVlsvFileFormat::avtVlsvFileFormat(const char *filename): avtSTMDFileFormat(&filename,1) {
   #ifdef PARALLEL
      MPI_Comm_size(MPI_COMM_WORLD,&mpiProcessCount);
      MPI_Comm_rank(MPI_COMM_WORLD,&mpiRank);
   #endif
   
   objectNumber = ++objectCounter;
   
   debug1 << "VLSV plugin constructor called " << printProcessInfo() << endl;
   debug2 << "VLSV\t opening file '" << filename << "'" << endl;
   debug3 << "VLSV\t object " << objectNumber << " / " << objectCounter << endl;
   
   // INITIALIZE DATA MEMBERS
   inputFile = filename;
   vlsvReader = NULL;
   
   /*
   // TEST
   #ifdef PARALLEL
      domainOffsets = NULL;
   #endif
   // END TEST
   */
   
   FreeUpResources();
}

avtVlsvFileFormat::~avtVlsvFileFormat() {
   debug1 << "VLSV plugin destructor called " << printProcessInfo() << endl;
   debug2 << "VLSV\t file '" << inputFile << "'" << endl;
   debug3 << "VLSV\t object " << objectNumber << " / " << objectCounter << endl;
   
   FreeUpResources();
}

const char* avtVlsvFileFormat::GetType(void) {
   debug1 << "VLSV GetType called" << endl;
   debug2 << "VLSV\t file '" << inputFile << "'" << endl;
   debug3 << "VLSV\t object " << objectNumber << " / " << objectCounter << endl;
   
   return "VLSV file format";
}

// ****************************************************************************
//  Method: avtVlsvFileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: sandroos -- generated by xml2avt
//  Creation:   Fri Jan 25 14:19:12 PST 2013
//
// ****************************************************************************

void avtVlsvFileFormat::FreeUpResources(void) {
   debug1 << "VLSV FreeUpResources called " << printProcessInfo() << endl;
   debug2 << "VLSV\t file '" << inputFile << "'" << endl;
   debug3 << "VLSV\t object " << objectNumber << " / " << objectCounter << endl;

   // Delete VLSVReader:
   delete vlsvReader; vlsvReader = NULL;
   dataTime = INVALID_TIME;
   dataTimeFound = false;
   dataTimestep = INVALID_CYCLE;
   dataTimestepFound = false;
   metadataRead = false;

   // Deallocate mesh metadata:
   for (map<string,vlsvplugin::VisitMeshMetadata*>::iterator it=meshMetadata.begin(); it!=meshMetadata.end(); ++it) {
      delete it->second; it->second = NULL;
   }
   meshMetadata.clear();
   
   // Deallocate mesh readers:
   for (map<string,vlsvplugin::MeshReader*>::iterator it=meshReaders.begin(); it!=meshReaders.end(); ++it) {
      delete it->second; it->second = NULL;
   }
   meshReaders.clear();
   
   /*
   // TEST
   #ifdef PARALLEL
      delete [] domainOffsets; domainOffsets = NULL;
   #endif
   // END TEST
   */
}

void avtVlsvFileFormat::addMesh(avtDatabaseMetaData* md,const vlsvplugin::VisitMeshMetadata* const meshMetadata) {
   debug1 << "VLSV\t\t addMesh called for mesh " << meshMetadata->getName() << endl;
   debug2 << "VLSV\t\t spatial dim: " << meshMetadata->getSpatialDimension() << " topolog dim: " << meshMetadata->getTopologicalDimension() << endl;
   debug2 << "VLSV\t\t total zones: " << meshMetadata->getNumberOfTotalZones() << endl;
   
   avtMeshMetaData* mesh = new avtMeshMetaData;
   mesh->name = meshMetadata->getName();
   mesh->meshType = meshMetadata->getMeshType();
   mesh->numBlocks = meshMetadata->getNumberOfDomains();
   mesh->blockOrigin = meshMetadata->getBlockOrigin();
   mesh->cellOrigin = 0;
   mesh->spatialDimension = meshMetadata->getSpatialDimension();
   mesh->topologicalDimension = meshMetadata->getTopologicalDimension();
   mesh->blockTitle = "blocks";
   mesh->blockPieceName = "block";

   mesh->xLabel = meshMetadata->getXLabel();
   mesh->yLabel = meshMetadata->getYLabel();   
   mesh->xUnits = meshMetadata->getXUnits();
   mesh->yUnits = meshMetadata->getYUnits();   

   if (meshMetadata->getSpatialDimension() == 3) {
      mesh->zLabel = meshMetadata->getZLabel();
      mesh->zUnits = meshMetadata->getZUnits();
   }
   
   mesh->SetNumberCells(meshMetadata->getNumberOfTotalZones());
   mesh->hasLogicalBounds = false;
   mesh->hasSpatialExtents = false;
   
   /*
   if (bounds != NULL) {
      mesh->SetBounds(bounds);
      mesh->hasLogicalBounds = true;
   } else {
      mesh->hasLogicalBounds = false;
   }
   
   if (extents != NULL) {
      mesh->SetExtents(extents);
      mesh->hasSpatialExtents = true;
   } else {
      mesh->hasSpatialExtents = false;
   }*/
   
   md->Add(mesh);
}

// ****************************************************************************
//  Method: avtVlsvFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: sandroos -- generated by xml2avt
//  Creation:   Fri Jan 25 14:19:12 PST 2013
//
// ****************************************************************************

void avtVlsvFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData* md) {
   debug1 << "VLSV PopulateDatabaseMetaData called " << printProcessInfo() << endl;
   debug2 << "VLSV\t file'" << inputFile << "' timestep: " << timestep << endl;
   debug3 << "VLSV\t object " << objectNumber << " / " << objectCounter << endl;

   // ActivateTimeStep should get called prior to this function.
   // Check that a VLSV file is open:
   if (vlsvReader == NULL) {
      debug2 << "VLSV\t VLSVReader in NULL, calling ActivateTimestep()." << endl;
      ActivateTimestep();
   }
   string dummy;
   if (vlsvReader->getFileName(dummy) == false) {
      debug2 << "VLSV\t ERROR: Input file has not been opened." << endl;
      return;
   }
   
   // Read simulation time and time step.
   // Add them to metadata if they were found:
   GetTime();
   if (dataTimeFound == true) {
      debug4 << "VLSV\t file time is    : " << dataTime << endl;
      md->SetTime(timestep,dataTime);
      md->SetTimeIsAccurate(true,timestep);
   }
   GetCycle();
   if (dataTimestepFound == true) {
      debug4 << "VLSV\t file timestep is: " << dataTimestep << endl;
      md->SetCycle(timestep,dataTimestep);
      md->SetCycleIsAccurate(true,timestep);
   }

   // Tell VisIt that metadata must be repopulated on every state change:
   md->SetMustRepopulateOnStateChange(true);
   
    //
    // CODE TO ADD A MESH
    //
    // string meshname = ...
    //
    // AVT_RECTILINEAR_MESH, AVT_CURVILINEAR_MESH, AVT_UNSTRUCTURED_MESH,
    // AVT_POINT_MESH, AVT_SURFACE_MESH, AVT_UNKNOWN_MESH
    // avtMeshType mt = AVT_RECTILINEAR_MESH;
    //
    // int nblocks = 1;  <-- this must be 1 for STSD
    // int block_origin = 0;
    // int spatial_dimension = 2;
    // int topological_dimension = 2;
    // double *extents = NULL;
    //
    // Here's the call that tells the meta-data object that we have a mesh:
    //
    // AddMeshToMetaData(md, meshname, mt, extents, nblocks, block_origin,
    //                   spatial_dimension, topological_dimension);
    //
   
   // TODO:
   // - Read all mesh names and types
   // - Add mesh names and types to VisIt metadata
   if (metadataRead == false) {
      if (readMetadata() == false) {
	 debug1 << "VLSV\t ERROR: Failed to read metadata" << endl;
	 return;
      }
   }
   
   for (map<string,vlsvplugin::VisitMeshMetadata*>::iterator it=meshMetadata.begin(); it!=meshMetadata.end(); ++it) {
      addMesh(md,it->second);
   }
   
   //
   // CODE TO ADD A SCALAR VARIABLE
   //
   // string mesh_for_this_var = meshname; // ??? -- could be multiple meshes
   // string varname = ...
   //
   // AVT_NODECENT, AVT_ZONECENT, AVT_UNKNOWN_CENT
   // avtCentering cent = AVT_NODECENT;
   //
   //
   // Here's the call that tells the meta-data object that we have a var:
   //
   // AddScalarVarToMetaData(md, varname, mesh_for_this_var, cent);
   //
   // CODE TO ADD A VECTOR VARIABLE
   //
   // string mesh_for_this_var = meshname; // ??? -- could be multiple meshes
   // string varname = ...
   // int vector_dim = 2;
   //
   // AVT_NODECENT, AVT_ZONECENT, AVT_UNKNOWN_CENT
   // avtCentering cent = AVT_NODECENT;
   //
   //
   // Here's the call that tells the meta-data object that we have a var:
   //
   // AddVectorVarToMetaData(md, varname, mesh_for_this_var, cent,vector_dim);
   //
   // CODE TO ADD A TENSOR VARIABLE
   //
   // string mesh_for_this_var = meshname; // ??? -- could be multiple meshes
   // string varname = ...
   // int tensor_dim = 9;
   //
   // AVT_NODECENT, AVT_ZONECENT, AVT_UNKNOWN_CENT
   // avtCentering cent = AVT_NODECENT;
   //
   //
   // Here's the call that tells the meta-data object that we have a var:
   //
   // AddTensorVarToMetaData(md, varname, mesh_for_this_var, cent,tensor_dim);
   //
   
   for (map<string,vlsvplugin::VisitMeshMetadata*>::iterator it=meshMetadata.begin(); it!=meshMetadata.end(); ++it) {
      avtCentering centering;
      const vector<vlsvplugin::VariableMetadata>& variables = it->second->getVariables();
      for (vector<vlsvplugin::VariableMetadata>::const_iterator var=variables.begin(); var!=variables.end(); ++var) {
	 // Determine variable centering:
	 if ((*var).centering == vlsvplugin::ZONE_CENTERED) centering = AVT_ZONECENT;
	 else centering = AVT_NODECENT;

	 // Add variable as a correct type to mesh:
	 switch ((*var).vectorSize) {
	  case 1:
	    AddScalarVarToMetaData(md,(*var).name,it->second->getName(),centering);
	    break;
	  case 2:
	    AddVectorVarToMetaData(md,(*var).name,it->second->getName(),centering,2);
	    break;
	  case 3:
	    AddVectorVarToMetaData(md,(*var).name,it->second->getName(),centering,3);
	    break;
	  case 9:
	    AddTensorVarToMetaData(md,(*var).name,it->second->getName(),centering,9);
	    break;
	  default:
	    AddArrayVarToMetaData(md,(*var).name,(*var).vectorSize,it->second->getName(),centering);
	    break;
	 }
      }
   }
   
   //
   // CODE TO ADD A MATERIAL
   //
   // string mesh_for_mat = meshname; // ??? -- could be multiple meshes
   // string matname = ...
   // int nmats = ...;
   // vector<string> mnames;
   // for (int i = 0 ; i < nmats ; i++)
   // {
   //     char str[32];
   //     sprintf(str, "mat%d", i);
   //     -- or -- 
   //     strcpy(str, "Aluminum");
   //     mnames.push_back(str);
   // }
   // 
   // Here's the call that tells the meta-data object that we have a mat:
   //
   // AddMaterialToMetaData(md, matname, mesh_for_mat, nmats, mnames);
   //
   //
   // Here's the way to add expressions:
   //Expression momentum_expr;
   //momentum_expr.SetName("momentum");
   //momentum_expr.SetDefinition("{u, v}");
   //momentum_expr.SetType(Expression::VectorMeshVar);
   //md->AddExpression(&momentum_expr);
   //Expression KineticEnergy_expr;
   //KineticEnergy_expr.SetName("KineticEnergy");
   //KineticEnergy_expr.SetDefinition("0.5*(momentum*momentum)/(rho*rho)");
   //KineticEnergy_expr.SetType(Expression::ScalarMeshVar);
   //md->AddExpression(&KineticEnergy_expr);
}

void avtVlsvFileFormat::ActivateTimestep(void) {
   debug1 << "VLSV ActivateTimestep called " << printProcessInfo() << endl;
   debug2 << "VLSV\t file '" << inputFile << "' timestep: " << timestep << endl;
   debug3 << "VLSV\t object " << objectNumber << " / " << objectCounter << endl;
   
   // Delete old VLSVReader:
   delete vlsvReader; vlsvReader = NULL;

   /*
   // TEST
   #ifdef PARALLEL
      delete [] domainOffsets; domainOffsets = NULL;
      N_domains = 2*mpiProcessCount+1;
   #endif
   // END TEST
   */

   // Create new VLSVReader and open given file:
   vlsvReader = new vlsv::Reader;
   if (vlsvReader->open(inputFile) == false) {
      debug2 << "VLSV\t ERROR: VLSVReader failed to open input file '" << inputFile << "'" << endl;
      vlsvReader->close();
      delete vlsvReader; vlsvReader = NULL;
      EXCEPTION1(InvalidDBTypeException,"VLSV Plugin could not open the file.");
      return;
   }

   // Re-read metadata if necessary:
   if (metadataRead == false) {
      if (readMetadata() == false) {
         debug2 << "VLSV\t ERROR: Failed to read metadata" << endl;
         vlsvReader->close();
         delete vlsvReader; vlsvReader = NULL;
         EXCEPTION1(InvalidDBTypeException,"VLSV Plugin could not open the file.");
         return;
      }
   }
}

// ****************************************************************************
//  Method: avtVlsvFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: sandroos -- generated by xml2avt
//  Creation:   Fri Jan 25 14:19:12 PST 2013
//
// ****************************************************************************

vtkDataSet* avtVlsvFileFormat::GetMesh(int domain,const char *meshname) {
   debug1 << "VLSV GetMesh called " << printProcessInfo() << endl;
   debug2 << "VLSV\t file '" << inputFile << "' mesh '" << meshname << "' domain: " << domain << " timestep: " << timestep << endl;
   debug3 << "VLSV\t object " << objectNumber << " / " << objectCounter << endl;
   
   // Check that VLSVReader exists:
   if (vlsvReader == NULL) {
      debug1 << "VLSV\t ERROR: VLSVReader is NULL" << endl;
      EXCEPTION1(InvalidVariableException, meshname);
      return NULL;
   }

   // Check that metadata has been read:
   if (metadataRead == false) {
      debug1 << "VLSV\t ERROR: Metadata not read" << endl;
      EXCEPTION1(InvalidVariableException, meshname);
      return NULL;
   }
   
   // Get metadata:
   map<string,vlsvplugin::VisitMeshMetadata*>::iterator metadata = meshMetadata.find(meshname);
   if (metadata == meshMetadata.end()) {
      debug2 << "VLSV\t ERROR: Metadata for mesh '" << meshname << "' not found" << endl;
      EXCEPTION1(InvalidVariableException, meshname);
      return NULL;
   }

   // Get mesh reader:
   map<string,vlsvplugin::MeshReader*>::iterator reader = meshReaders.find(meshname);
   if (reader == meshReaders.end()) {
      debug2 << "VLSV\t ERROR: Mesh reader for mesh '" << meshname << "' not found" << endl;
      EXCEPTION1(InvalidVariableException, meshname);
      return NULL;
   }

   std::chrono::time_point<std::chrono::high_resolution_clock> t_start, t_end;
   t_start = std::chrono::high_resolution_clock::now();

   // Read mesh coordinates:
   void* meshOut = NULL;
   if (reader->second->readMesh(vlsvReader,metadata->second,domain,meshOut) == false) {
      debug2 << "VLSV\t ERROR: Mesh reader failed to generate mesh" << endl;
   }
   
   t_end = std::chrono::high_resolution_clock::now();
   std::chrono::duration<double> elapsed_seconds = t_end-t_start;
   debug1 << "VLSV\t\t GetMesh took " << elapsed_seconds.count() << " s" << endl;

   previousMesh = meshname;
   return reinterpret_cast<vtkDataSet*>(meshOut);
}


// ****************************************************************************
//  Method: avtVlsvFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      varname    The name of the variable requested.
//
//  Programmer: sandroos -- generated by xml2avt
//  Creation:   Fri Jan 25 14:19:12 PST 2013
//
// ****************************************************************************

bool avtVlsvFileFormat::PrepareVariable(int domain,const char* varName,
					std::map<std::string,vlsvplugin::VisitMeshMetadata*>::const_iterator& metadata,
					std::map<std::string,vlsvplugin::MeshReader*>::const_iterator& meshReader,
					std::vector<vlsvplugin::VariableMetadata>::const_iterator& variableMetadata) {
   metadata = meshMetadata.end();
   meshReader = meshReaders.end();
   
   // Check that VLSVReader exists:
   if (vlsvReader == NULL) {
      debug1 << "VLSV\t ERROR: VLSVReader is NULL" << endl;
      return false;
   }
   
   // Check that metadata has been read:
   if (metadataRead == false) {
      debug1 << "VLSV\t ERROR: Metadata not read" << endl;
      return false;
   }
   
   // Figure out the mesh which has the variable, first try the mesh 
   // that was accessed last time:
   bool found = false;
   string meshName;
   metadata = meshMetadata.find(previousMesh);
   const vector<vlsvplugin::VariableMetadata>& variables = metadata->second->getVariables();
   for (variableMetadata=variables.begin(); variableMetadata!=variables.end(); ++variableMetadata) {
      if (variableMetadata->name == varName) {
	 meshName = previousMesh;
	 found = true;
	 break;
      }
   }
   
   // Try all other meshes:
   if (found == false) for (metadata=meshMetadata.begin(); metadata!=meshMetadata.end(); ++metadata) {
      if (metadata->second->getName() == previousMesh) continue;
      const vector<vlsvplugin::VariableMetadata>& variables = metadata->second->getVariables();
      for (variableMetadata=variables.begin(); variableMetadata!=variables.end(); ++variableMetadata) {
	 if (variableMetadata->name == varName) {
	    meshName     = metadata->second->getName();
	    previousMesh = metadata->second->getName();
	    found = true;
	    break;
	 }
      }
      if (found == true) break;
   }
   
   // Exit if correct mesh was not found:
   if (found == false) {
      debug1 << "VLSV\t ERROR: Could not find correct mesh for variable '" << varName << "'" << endl;
      return found;
   } else {
      debug4 << "VLSV\t Mesh '" << meshName << "' contains variable '" << varName << "'" << endl;
   }
   
   // Get mesh reader:
   meshReader = meshReaders.find(meshName);
   if (meshReader == meshReaders.end()) {
      debug2 << "VLSV\t ERROR: Mesh reader for mesh '" << meshName << "' not found" << endl;
      return false;
   }
   
   return true;
}

vtkDataArray* avtVlsvFileFormat::ReadVariable(int domain,const char* varName) {
   debug1 << "VLSV ReadVariable called " << printProcessInfo() << endl;
   debug2 << "VLSV file '" << inputFile << "' domain: " << domain << " timestep: " << timestep << " variable '" << varName << "'" << endl;
   debug3 << "VLSV\t object " << objectNumber << " / " << objectCounter << endl;
   
   // Prepare variable read, i.e. find pointers to metadata associated with 
   // the correct mesh, mesh reader, and variable:
   map<string,vlsvplugin::VisitMeshMetadata*>::const_iterator metadata;
   map<string,vlsvplugin::MeshReader*>::const_iterator meshReader;
   vector<vlsvplugin::VariableMetadata>::const_iterator variableMetadata;
   if (PrepareVariable(domain,varName,metadata,meshReader,variableMetadata) == false) {
      debug2 << "VLSV\t ERROR: PrepareVariable failed" << endl;
      EXCEPTION1(InvalidVariableException, varName);
      return NULL;
   }

   void* variableOut = NULL;
   if (meshReader->second->readVariable(vlsvReader,metadata->second,*variableMetadata,domain,variableOut) == false) {
      debug1 << "VLSV\t ERROR: Failed to read variable data" << endl;
   }
   
   return reinterpret_cast<vtkDataArray*>(variableOut);
}

vtkDataArray* avtVlsvFileFormat::GetVar(int domain,const char* varname) {
   vtkDataArray* rv = ReadVariable(domain,varname);
   if (rv == NULL) EXCEPTION1(InvalidVariableException, varname);
   return rv;
}


// ****************************************************************************
//  Method: avtVlsvFileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      varname    The name of the variable requested.
//
//  Programmer: sandroos -- generated by xml2avt
//  Creation:   Fri Jan 25 14:19:12 PST 2013
//
// ****************************************************************************

vtkDataArray* avtVlsvFileFormat::GetVectorVar(int domain,const char* varname) {
   vtkDataArray* rv = ReadVariable(domain,varname);
   if (rv == NULL) EXCEPTION1(InvalidVariableException, varname);
   return rv;
}
   
int avtVlsvFileFormat::GetCycle(void) {
   debug1 << "VLSV GetCycle called " << printProcessInfo() << endl;
   debug2 << "VLSV \t file '" << inputFile << "' timestep: " << timestep << endl;
   debug3 << "VLSV\t object " << objectNumber << " / " << objectCounter << endl;

   // Check that VLSVReader is not NULL:
   if (vlsvReader == NULL) {
      debug1 << "VLSV\t ERROR: VLSVReader is NULL." << endl;
      return INVALID_CYCLE;
   }
   
   // Read simulation timestep:
   dataTimestepFound = true;
   if (vlsvReader->readParameter("timestep",dataTimestep) == false) {
      dataTimestep = INVALID_CYCLE;
      dataTimestepFound = false;
   }
   
   if (dataTimestepFound == true) debug4 << "VLSV\t file time step is: " << dataTimestep << endl;
   else debug4 << "VLSV\t file does not contain timestep" << endl;
   return dataTimestep;
}

double avtVlsvFileFormat::GetTime(void) {
   debug1 << "VLSV GetTime called " << printProcessInfo() << endl;
   debug2 << "VLSV\t file '" << inputFile << "' timestep " << timestep << endl;
   debug3 << "VLSV\t object " << objectNumber << " / " << objectCounter << endl;

   // Check that VLSVReader is not NULL:
   if (vlsvReader == NULL) {
      debug1 << "VLSV\t ERROR: VLSVReader is NULL." << endl;
      return INVALID_TIME;
   }
   
   // Read simulation time:
   dataTimeFound = true;
   if (vlsvReader->readParameter("time",dataTime) == false) {
      dataTime = INVALID_TIME;
      dataTimeFound = false;
   }
   
   if (dataTimeFound == true) debug4 << "VLSV\t file time is: " << dataTime << endl;
   else debug4 << "VLSV\t file does not contain time" << endl;
   return dataTime;
}

std::string avtVlsvFileFormat::printProcessInfo() const {
   stringstream out;
   #ifdef PARALLEL
      out << "MPI process " << mpiRank+1 << "/" << mpiProcessCount;
   #else

   #endif
   return out.str();
}

bool avtVlsvFileFormat::readMetadata() {
   debug1 << "VLSV\t\t readMetadata called" << endl;

   bool success = true;
   metadataRead = false;

   // Check that VLSVReader exists:
   if (vlsvReader == NULL) {
      return false;
   }
   
   // Read mesh names:
   set<string> meshNames;
   if (vlsvReader->getUniqueAttributeValues("MESH","name",meshNames) == false) {
      return false;
   }
   
   // Iterate over all meshes in the file:
   for (set<string>::const_iterator it=meshNames.begin(); it!=meshNames.end(); ++it) {
      debug4 << "VLSV\t found mesh '" << *it << "'" << endl;
   
      // Read mesh type:
      map<string,string> attribsOut;
      list<pair<string,string> > attribsIn;
      attribsIn.push_back(make_pair("name",*it));
      vlsvReader->getArrayAttributes("MESH",attribsIn,attribsOut);
      if (attribsOut.find("type") == attribsOut.end()) {
	     debug4 << "VLSV\t skipping it because its type is unspecified" << endl;
	     continue;
      }
      
      // Check if mesh type corresponds to one of types supported by VisIt:
      bool supportedType = true;
      if (attribsOut["type"] == vlsv::mesh::STRING_POINT) {
	 vlsvplugin::VisitPointMeshMetadata* pointMesh = new vlsvplugin::VisitPointMeshMetadata();
	 if (pointMesh->read(vlsvReader,attribsOut) == false) {
	    debug2 << "VLSV\t\t Failed to read point mesh metadata" << endl;
	    delete pointMesh; pointMesh = NULL;
	 } else {
	    // Insert metadata to map meshMetadata:
	    pair<map<string,vlsvplugin::VisitMeshMetadata*>::iterator,bool> position = 
	      meshMetadata.insert(make_pair(*it,pointMesh));
	    
	    if (position.second == true) {
	       meshReaders[*it] = new vlsvplugin::VisitPointMeshReader();
	       debug4 << "VLSV\t\t Created point mesh reader" << endl;
	    } else {
	       debug2 << "VLSV\t\t Failed to insert point mesh metadata" << endl;
	       map<string,vlsvplugin::VisitMeshMetadata*>::iterator tmp = meshMetadata.find(*it);
	       delete tmp->second; tmp->second = NULL;
	       meshMetadata.erase(tmp);
	    }
	 }
      } else if (attribsOut["type"] == vlsv::mesh::STRING_QUAD_MULTI) {
	 vlsvplugin::VisitQuadMultiMeshMetadata* multiMesh = new vlsvplugin::VisitQuadMultiMeshMetadata();
	 if (multiMesh->read(vlsvReader,attribsOut) == false) {
	    debug2 << "VLSV\t\t Failed to read multimesh metadata" << endl;
	    delete multiMesh; multiMesh = NULL;
	 } else {
	    // Insert metadata to map meshMetadata:
	    pair<map<string,vlsvplugin::VisitMeshMetadata*>::iterator,bool> position = 
	      meshMetadata.insert(make_pair(*it,multiMesh));
	 
	    if (position.second == true) {
	       meshReaders[*it] = new vlsvplugin::VisitQuadMultiMeshReader();
	       debug4 << "VLSV\t\t Created quad multimesh reader" << endl;
	    } else {
	       debug2 << "VLSV\t\t Failed to insert quad multimesh metadata" << endl;
	       map<string,vlsvplugin::VisitMeshMetadata*>::iterator tmp = meshMetadata.find(*it);
	       delete tmp->second; tmp->second = NULL;
	       meshMetadata.erase(tmp);
	    }
	 }
      } else if (attribsOut["type"] == vlsv::mesh::STRING_UCD_AMR) {
	 vlsvplugin::VisitUCDAMRMetadata* amrUCD = new vlsvplugin::VisitUCDAMRMetadata();
	 if (amrUCD->read(vlsvReader,attribsOut) == false) {
	    debug2 << "VLSV\t\t Failed to read amr mesh metadata" << endl;
	    delete amrUCD; amrUCD = NULL;
	 } else {
	    // Insert metadata to map meshMetadata:
	    pair<map<string,vlsvplugin::VisitMeshMetadata*>::iterator,bool> position =
	      meshMetadata.insert(make_pair(*it,amrUCD));
	    
	    if (position.second == true) {
	       meshReaders[*it] = new vlsvplugin::VisitUCDAMRReader();
	       debug4 << "VLSV\t\t Created UCD AMR reader" << endl;
	    } else {
	       debug2 << "VLSV\t\t Failed to insert UCD AMR metadata" << endl;
	       map<string,vlsvplugin::VisitMeshMetadata*>::iterator tmp = meshMetadata.find(*it);
	       delete tmp->second; tmp->second = NULL;
	       meshMetadata.erase(tmp);
	    }
	 }
      } else if (attribsOut["type"] == vlsv::mesh::STRING_UCD_MULTI) {
	 vlsvplugin::VisitUCDMultiMeshMetadata* multiUCD = new vlsvplugin::VisitUCDMultiMeshMetadata();
	 if (multiUCD->read(vlsvReader,attribsOut) == false) {
	    debug2 << "VLSV\t\t Failed to read multimesh metadata" << endl;
	    delete multiUCD; multiUCD = NULL;
	 } else {
	    // Insert metadata to map meshMetadata:
	    pair<map<string,vlsvplugin::VisitMeshMetadata*>::iterator,bool> position =
	      meshMetadata.insert(make_pair(*it,multiUCD));
	    
	    if (position.second == true) {
	       meshReaders[*it] = new vlsvplugin::VisitUCDMultiMeshReader();
	       debug4 << "VLSV\t\t Created UCD multimesh reader" << endl;
	    } else {
	       debug2 << "VLSV\t\t Failed to insert UCD multimesh metadata" << endl;
	       map<string,vlsvplugin::VisitMeshMetadata*>::iterator tmp = meshMetadata.find(*it);
	       delete tmp->second; tmp->second = NULL;
	       meshMetadata.erase(tmp);
	    }
	 }
      } else if (attribsOut["type"] == vlsv::mesh::STRING_UCD_GENERIC_MULTI) {
	 vlsvplugin::VisitUCDGenericMultiMeshMetadata* multiUCD = new vlsvplugin::VisitUCDGenericMultiMeshMetadata();
	 if (multiUCD->read(vlsvReader,attribsOut) == false) {
	    debug2 << "VLSV\t\t Failed to read generic UCD multimesh metadata" << endl;
	    delete multiUCD; multiUCD = NULL;
	 } else {
	    // Insert metadata to map meshMetadata:
	    pair<map<string,vlsvplugin::VisitMeshMetadata*>::iterator,bool> position =
	      meshMetadata.insert(make_pair(*it,multiUCD));
	    
	    if (position.second == true) {
	       meshReaders[*it] = new vlsvplugin::VisitUCDGenericMultiMeshReader();
	       debug4 << "VLSV\t\t Created Generic UCD multimesh reader" << endl;
	    } else {
	       debug2 << "VLSV\t\t Failed to insert Generic UCD multimesh metadata" << endl;
	       map<string,vlsvplugin::VisitMeshMetadata*>::iterator tmp = meshMetadata.find(*it);
	       delete tmp->second; tmp->second = NULL;
	       meshMetadata.erase(tmp);
	    }
	 }	    
      } else {
	 supportedType = false;
      }
   }

   metadataRead = true;
   return success;
}

